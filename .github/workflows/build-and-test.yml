name: Build and Test

on:
  push:
    branches: [ master, main ]
  pull_request:
    branches: [ master, main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/mkdocs-docker

permissions:
  contents: read
  packages: write

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.tags }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Test Docker image basic functionality
      run: |
        # Test that the container shows usage when run without valid command
        IMAGE_TAG=$(echo "${{ steps.meta.outputs.tags }}" | head -n1)
        if docker run --rm $IMAGE_TAG 2>&1 | grep -q "Usage:"; then
          echo "Docker container responding correctly"
        else
          echo "Error: Container not responding as expected"
          exit 1
        fi

  test:
    runs-on: ubuntu-latest
    needs: build

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Pull Docker image
      run: |
        IMAGE_TAG=$(echo "${{ needs.build.outputs.image-tag }}" | head -n1)
        docker pull $IMAGE_TAG
        docker tag $IMAGE_TAG mkdocs-docker
        echo "Using image: $IMAGE_TAG"

    - name: Make script executable
      run: chmod +x mkdockerize.sh

    - name: Test produce command
      run: |
        ./mkdockerize.sh produce ./test-project > site.tar.gz
        ls -la site.tar.gz
        if [ ! -f site.tar.gz ]; then
          echo "Error: site.tar.gz not created"
          exit 1
        fi

    - name: Test produce output size
      run: |
        SIZE=$(stat -c%s site.tar.gz)
        if [ $SIZE -lt 1000 ]; then
          echo "Error: Generated site.tar.gz too small ($SIZE bytes)"
          exit 1
        fi
        echo "Generated site.tar.gz size: $SIZE bytes"

    - name: Test tar.gz content
      run: |
        if ! tar -tzf site.tar.gz | grep -q "index.html"; then
          echo "Error: No index.html found in generated site"
          echo "Contents of site.tar.gz:"
          tar -tzf site.tar.gz
          exit 1
        fi
        echo "✓ index.html found in generated site"

    - name: Test serve command (background)
      run: |
        # Ensure site.tar.gz exists before testing serve (regenerate if needed)
        if [ ! -f site.tar.gz ]; then
          echo "site.tar.gz not found, regenerating for serve test..."
          ./mkdockerize.sh produce ./test-project > site.tar.gz
        fi

        echo "Files before serve test:"
        ls -la *.tar.gz

        # Start serve in background using a subshell with proper terminal simulation
        (timeout 30s ./mkdockerize.sh serve) > serve.log 2>&1 &
        SERVE_PID=$!
        sleep 15

        # Check serve log for errors
        if [ -f serve.log ]; then
          echo "Serve log output:"
          cat serve.log
        fi

        # Test if server is responding
        if curl -f http://localhost:8000/ >/dev/null 2>&1; then
          echo "Server is responding correctly"
        else
          echo "Error: Server not responding"
          echo "Checking if Docker container is running:"
          docker ps
          echo "Checking Docker logs:"
          docker logs $(docker ps -q --filter ancestor=mkdocs-docker) 2>/dev/null || echo "No Docker container found"
          # Kill the script process
          kill $SERVE_PID 2>/dev/null || true
          # Ensure Docker containers are stopped
          docker stop $(docker ps -q --filter ancestor=mkdocs-docker) 2>/dev/null || true
          exit 1
        fi

        # Cleanup: Kill the script process and stop any running containers
        kill $SERVE_PID 2>/dev/null || true

        # Give the script a moment to handle the signal gracefully
        sleep 2

        # Force stop any remaining Docker containers to prevent port conflicts
        REMAINING_CONTAINERS=$(docker ps -q --filter ancestor=mkdocs-docker 2>/dev/null || true)
        if [ -n "$REMAINING_CONTAINERS" ]; then
          echo "Stopping remaining Docker containers: $REMAINING_CONTAINERS"
          docker stop $REMAINING_CONTAINERS 2>/dev/null || true
        fi

    - name: Test custom project directory
      run: |
        ./mkdockerize.sh produce test-project > site.tar.gz
        ls -la site.tar.gz
        echo "✓ Custom project directory test completed"

    - name: Test script error handling
      run: |
        # Test with non-existent directory
        if ./mkdockerize.sh produce nonexistent-dir 2>/dev/null; then
          echo "Error: Script should fail with non-existent directory"
          exit 1
        fi
        echo "Error handling test passed"
